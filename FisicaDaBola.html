<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Teste</title>
</head>

<body>
  <canvas id="myCanvas" width="500" height="500" style="border:solid 1px blue">
    Your browser does not support HTML5 Canvas.
  </canvas>

  <script>
    
    let canvas = document.querySelector('#myCanvas');
    let ctx = canvas.getContext("2d");

    const W = canvas.width, H = canvas.height;

    const squareSize = 200;
    const halfSize = squareSize / 2;
    const centerX = W / 2;
    const centerY = H / 2;

    let angle = 0; // initial angle of rotation

    // Ball properties
    let ball = {
      radius: 15,
      color: "orange",
      x: centerX,      // initial x position
      y: centerY, // initial y position
      dx: 0,           // x velocity
      dy: 0,           // y velocity
      gravity: 0.1,    // gravity affecting the ball
      friction: 0.4,  // friction factor on each bounce to slow it down over time

      draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
      },

      update() {
        // Apply gravity
        this.dy += this.gravity;

        // Calculate rotated position for collision
        let rotatedPos = rotatePoint(this.x, this.y, centerX, centerY, -angle);

        // Define the rotated square in rotated space
        const rect = {
          x: centerX - halfSize,
          y: centerY - halfSize,
          width: squareSize,
          height: squareSize
        };

        // Collision detection and response in rotated space
        if (rotatedPos.x - this.radius < rect.x) {
          rotatedPos.x = rect.x + this.radius;
          this.dx *= -this.friction;
        } else if (rotatedPos.x + this.radius > rect.x + rect.width) {
          rotatedPos.x = rect.x + rect.width - this.radius;
          this.dx *= -this.friction;
        }
        if (rotatedPos.y - this.radius < rect.y) {
          rotatedPos.y = rect.y + this.radius;
          this.dy *= -this.friction;
        } else if (rotatedPos.y + this.radius > rect.y + rect.height) {
          rotatedPos.y = rect.y + rect.height - this.radius;
          this.dy *= -this.friction;
        }

        // Rotate back adjusted position
        let adjustedPos = rotatePoint(rotatedPos.x, rotatedPos.y, centerX, centerY, angle);
        this.x = adjustedPos.x;
        this.y = adjustedPos.y;

        // Update ball's position with velocities
        this.x += this.dx;
        this.y += this.dy;
      }
    };

    function drawSquare() {
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(angle);
      ctx.strokeStyle = "blue";
      ctx.lineWidth = 3;
      ctx.strokeRect(-halfSize, -halfSize, squareSize, squareSize);
      ctx.restore();
    }

    // Rotate a point around an origin
    function rotatePoint(px, py, ox, oy, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const dx = px - ox;
      const dy = py - oy;
      
      return {
        x: ox + dx * cos - dy * sin,
        y: oy + dx * sin + dy * cos
      };
    }

    function render() {
      // Clear canvas
      ctx.clearRect(0, 0, W, H);

      // Draw and update elements
      drawSquare();
      ball.draw();
      ball.update();

      requestAnimationFrame(render);
    }

    // Update angle based on mouse position
    canvas.addEventListener("mousemove", (event) => {
      angle = (event.clientX / W) * Math.PI * 2;
    });

    window.onload = render;

  </script>
</body>

</html>
